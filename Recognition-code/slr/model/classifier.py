import numpy #: импорт библотеки NumPy для работы с массивами и матрицами, а также множеством мат функций
import tensorflow

class KeyPointClassifier(object):
    def __init__( #: Конструктор с аргументами и значениями по умолчанию
        self, #: ключевое слово self используется в методах класса для обращения к атрибутам и методам этого же объекта класса.
        model_path = "slr/model/slr_model.tflite", #: указание пути к модели
        num_threads = 1 #: аргумент для установки количества потоков
    ):
        '''
        Инициализируется объект Interpreter из TensorFlow Lite,
        который используется для загрузки и выполнения модели машинного
        обучения в формате TensorFlow Lite (TFLite).
        '''
        self.interpreter = tensorflow.lite.Interpreter(
            model_path=model_path,
            num_threads=num_threads
        )
        self.interpreter.allocate_tensors() #: метод объекта интерпретатора TensorFlow Lite, который используется для выделения
        #: памяти под входные и выходные тензоры модели.

        self.input_details = self.interpreter.get_input_details() #: метод используется для получения информации о входных тензорах
        #: модели, такой как их имя, тип данных, форма и т. д.
        self.output_details = self.interpreter.get_output_details() #: модель используется для получения информации о выходных тензорах
        #: модели, такой как их имя, тип данных, форма и т. д.

    def __call__(self, landmark_list): #: метод, который используется для вызова экземпляра класса KeyPointClassifier как функции
        input_details_tensor_index = self.input_details[0]['index'] #: извлекаем индекс входного тензора из переменной input_details.
        #: Этот индекс будет использоваться для установки данных входного тензора.

        self.interpreter.set_tensor( #: устанавливаем данные входного тензора, используя метод set_tensor интерпретатора.
            input_details_tensor_index,
            numpy.array([landmark_list], dtupe=numpy.float32)
        )
        '''
        в этом случае мы передаем в качестве данных список точек ориентиров landmark_list, который должен быть преобразован
        в массив NumPy типа numpy.float32. Затем этот массив передается в интерпретатор, используя индекс входного тензора,
        полученный на предыдущем шаге.
        '''

        self.interpreter.invoke() #: запускает вычисления модели с использованием текущих значений тензоров входных данных и сохраняет
        #: результаты в тензорах выходных данных. Это позволяет получить прогнозы или вывод модели на заданных входных данных.

        output_details_tensor_index = self.output_details[0]['index'] #: представляет информацию о первом тензоре в списке выходных
        #: данных модели, включая его тип, форму и прочие характеристики.
        #: ['index'] используется для доступа к значению индекса этого тензора в списке. Этот индекс затем используется для установки
        #: значений в этот тензор или получения его значений после выполнения модели.

        #: Получает выходные данные модели из тензора с индексом output_details_tensor_index. Этот тензор содержит результаты работы модели
        result = self.interpreter.get_tensor(output_details_tensor_index) #:  предсказанные классы или вероятности для каждого класса.

        #:  условие для определения, насколько уверенно модель классифицирует входные данные.
        if max(numpy.squeeze(result)) > 0.5: #: squeeze преобразует результат в одномерный массив, чтобы упростить его обработку
            result_index = numpy.argmax(numpy.squeeze(result)) #: находит индекс элемента с максимальным значением в массиве result.
            #: Это индекс класса, который модель считает наиболее вероятным.
            return result_index
        else:
            return 25